"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sortPages = exports.sortFieldPositionsByXAndYCoordinates = exports.removeOrphanedFieldsFromJoydoc = exports.mergeAssoicatedFieldPositionsForMobilePage = exports.getPageOrder = exports.getMobileViewFromFile = exports.getDocumentFromTemplate = exports.getDefaultTemplate = exports.getDefaultJoyDocPage = exports.getDefaultJoyDocFile = exports.getDefaultJoyDoc = exports.getDefaultDocument = exports.getCleanedJoyDocPages = exports.getCleanedJoyDoc = exports.generateMobileViewFromFile = exports.generateMobilePageFieldPositions = exports.generateMobilePage = exports.formatTableFieldPositions = exports.duplicateDocumentPage = exports.duplicate = exports["default"] = exports.cleanPageOrder = void 0;
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _generateObjectId = _interopRequireDefault(require("./generateObjectId"));
var _validateObjectId = _interopRequireDefault(require("./validateObjectId"));
var _PageLayoutModes = _interopRequireDefault(require("./constants/PageLayoutModes"));
var _FieldPresentationModes = _interopRequireDefault(require("./constants/FieldPresentationModes"));
var _DocumentTypes = _interopRequireDefault(require("./constants/DocumentTypes"));
var _PageTypes = _interopRequireDefault(require("./constants/PageTypes"));
var _FieldTypes = _interopRequireDefault(require("./constants/FieldTypes"));
var _FieldDisplayTypes = _interopRequireDefault(require("./constants/FieldDisplayTypes"));
var _FileViews = _interopRequireDefault(require("./constants/FileViews"));
var _FormStyleOptions = _interopRequireDefault(require("./constants/FormStyleOptions"));
var _tableHelper = require("./tableHelper");
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2["default"])(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
/**
 * Create default page
 *
 * @param {Object} defaults
 * @return {Object}
 */
var getDefaultJoyDocPage = exports.getDefaultJoyDocPage = function getDefaultJoyDocPage() {
  var defaults = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return _objectSpread({
    _id: (0, _generateObjectId["default"])(),
    name: 'New Page',
    width: 816,
    height: 1056,
    rowHeight: 8,
    cols: 8,
    fieldPositions: [],
    layout: _PageLayoutModes["default"].grid,
    presentation: _FieldPresentationModes["default"].normal,
    padding: 24
  }, defaults);
};

/**
 * Create default file
 *
 * @param {Object} defaults
 * @param {Object} pageDefaults
 * @return {Object}
 */
var getDefaultJoyDocFile = exports.getDefaultJoyDocFile = function getDefaultJoyDocFile() {
  var defaults = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var pageDefaults = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var page = getDefaultJoyDocPage(pageDefaults);
  return _objectSpread({
    _id: (0, _generateObjectId["default"])(),
    name: 'New File',
    pageOrder: [page._id],
    pages: [page],
    styles: {
      margin: 4
    }
  }, defaults);
};

/**
 * Create default document
 *
 * @param {Object} defaults
 * @param {Object} pageDefaults
 * @return {Object}
 */
var getDefaultJoyDoc = exports.getDefaultJoyDoc = function getDefaultJoyDoc() {
  var defaults = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var fileDefaults = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var pageDefaults = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var id = (0, _generateObjectId["default"])();
  return _objectSpread({
    _id: id,
    identifier: "doc_".concat(id),
    name: 'New Doc',
    files: [getDefaultJoyDocFile(fileDefaults, pageDefaults)],
    fields: []
  }, defaults);
};

/**
 * Get Clean JoyDoc Format
 *
 * Solves Issue: https://app.zenhub.com/workspaces/joyfill-platform-5f07262b507391001f56c7f9/issues/gh/zionlabs/issues/2105
 *
 * This selector ensures a couple of things:
 * 1. Valid file inside the document.
 * 2. Valid page inside document file.
 * 3. All _id's (page, file, page, fieldPosition, field) are in a valid format
 * 4. Row order of table field is free from duplicate/deletedRow Ids
 *
 * @param {Object} doc
 * @returns {Object}
 */
var getCleanedJoyDoc = exports.getCleanedJoyDoc = function getCleanedJoyDoc(doc) {
  if (!doc) return getDefaultJoyDoc();
  var _removeOrphanedFields = removeOrphanedFieldsFromJoydoc(doc),
    nextDoc = _removeOrphanedFields.nextDoc;

  /**
   * Step 1.1: Replace doc._id if it is not valid
   */
  if (nextDoc._id && !(0, _validateObjectId["default"])(nextDoc._id)) nextDoc._id = (0, _generateObjectId["default"])();
  if (nextDoc.files && nextDoc.files.length > 0) {
    nextDoc.files = nextDoc.files.map(function (file) {
      var _nextFile$views;
      var nextFile = _objectSpread({}, file);

      /**
      * Step 1.2: Replace files[x]._id if it is not valid
      */
      if (nextFile._id && !(0, _validateObjectId["default"])(nextFile._id)) nextFile._id = (0, _generateObjectId["default"])();

      /**
      * Step 1.3: Replace page ids and field ids if they are not valid
      */
      nextFile.pages = getCleanedJoyDocPages(nextFile.pages);
      nextFile.pageOrder = cleanPageOrder(getPageOrder(nextFile.pageOrder, nextFile.pages), nextFile.pages);

      /**
      * Step 1.4: Replace view page ids and field ids if they are not valid
      */
      if ((nextFile === null || nextFile === void 0 ? void 0 : (_nextFile$views = nextFile.views) === null || _nextFile$views === void 0 ? void 0 : _nextFile$views.length) > 0) {
        nextFile.views = nextFile.views.map(function (view) {
          var nextView = _objectSpread({}, view);
          nextView.pages = getCleanedJoyDocPages(nextView.pages);
          nextView.pageOrder = cleanPageOrder(getPageOrder(nextView.pageOrder, nextView.pages), nextView.pages);
          return nextView;
        });
      }
      return nextFile;
    });
  } else {
    nextDoc.files = [getDefaultJoyDocFile()];
  }

  /**
   * Logic below is used to clean the table field rowOrder by removing the
   * deletedRowIds / duplicateRowIds from the rowOrder.
   **/
  if (nextDoc.fields && nextDoc.fields.length > 0) {
    nextDoc.fields = nextDoc.fields.map(function (field) {
      var nextField = _objectSpread({}, field);
      if (field.type === _FieldTypes["default"].table) {
        var cleanedRoworder = (0, _tableHelper.getCleanedRowOrder)(field.rowOrder, field.value);
        nextField.rowOrder = cleanedRoworder;
      }
      return nextField;
    });
  }
  return nextDoc;
};

/**
 * Remove orphaned fields from doc
 */

var removeOrphanedFieldsFromJoydoc = exports.removeOrphanedFieldsFromJoydoc = function removeOrphanedFieldsFromJoydoc(doc) {
  var _nextDoc$files;
  if (!doc) return getDefaultJoyDoc();
  var nextDoc = _objectSpread({}, doc);
  var associatedFieldIdLookup = {};
  nextDoc === null || nextDoc === void 0 ? void 0 : (_nextDoc$files = nextDoc.files) === null || _nextDoc$files === void 0 ? void 0 : _nextDoc$files.forEach(function (file) {
    var _file$views;
    /**
     * Primary view
     */
    file.pages.forEach(function (page) {
      page === null || page === void 0 ? void 0 : page.fieldPositions.forEach(function (fieldPosition) {
        return associatedFieldIdLookup[fieldPosition.field] = true;
      });
    });

    /**
     * Alternative view
     */
    (_file$views = file.views) === null || _file$views === void 0 ? void 0 : _file$views.forEach(function (view) {
      var _view$pages;
      view === null || view === void 0 ? void 0 : (_view$pages = view.pages) === null || _view$pages === void 0 ? void 0 : _view$pages.forEach(function (page) {
        page === null || page === void 0 ? void 0 : page.fieldPositions.forEach(function (fieldPosition) {
          return associatedFieldIdLookup[fieldPosition.field] = true;
        });
      });
    });
  });

  /**
  * Logic below removes orphaned fields (ie fields without fieldPositions)
  */
  var validFields = [];
  var deletedFields = [];
  nextDoc.fields.forEach(function (field) {
    if (associatedFieldIdLookup[field._id]) validFields.push(field);else deletedFields.push(field);
  });
  nextDoc.fields = validFields;
  return {
    nextDoc: nextDoc,
    deletedFields: deletedFields
  };
};

/**
 * Get Cleaned JoyDoc Pages
 *
 * Solves Issue: https://app.zenhub.com/workspaces/joyfill-platform-5f07262b507391001f56c7f9/issues/gh/zionlabs/issues/2105
 *
 * This selector ensures a couple of things:
 * 1. Valid page inside document file.pages array.
 * 2. All id's in pages and fieldPositions are valid format
 *
 * @param {Object} doc
 * @returns {Object}
 */
var getCleanedJoyDocPages = exports.getCleanedJoyDocPages = function getCleanedJoyDocPages(pages) {
  if ((pages === null || pages === void 0 ? void 0 : pages.length) > 0) {
    return pages.map(function (page) {
      /**
      * Step 1: Replace pages[x]._id if it is not valid
      */
      var nextPage = _objectSpread({}, page);
      if (nextPage._id && !(0, _validateObjectId["default"])(nextPage._id)) nextPage._id = (0, _generateObjectId["default"])();
      if (nextPage.fieldPositions && nextPage.fieldPositions.length > 0) {
        nextPage.fieldPositions = nextPage.fieldPositions.map(function (fieldPosition) {
          /**
          * Step 1.2: Replace fieldPosition _id and field reference if they are not valid
          */
          var nextFieldPosition = _objectSpread({}, fieldPosition);
          if (nextFieldPosition._id && !(0, _validateObjectId["default"])(nextFieldPosition._id)) nextFieldPosition._id = (0, _generateObjectId["default"])();
          if (nextFieldPosition.field && !(0, _validateObjectId["default"])(nextFieldPosition.field)) nextFieldPosition.field = (0, _generateObjectId["default"])();
          return nextFieldPosition;
        });
      } else {
        nextPage.fieldPositions = [];
      }
      return nextPage;
    });
  } else {
    return [getDefaultJoyDocPage()];
  }
};

/**
 * Get page order
 *
 * @param {Array} pages
 * @param {Array} pageOrder
 * @return {Array}
 */
var getPageOrder = exports.getPageOrder = function getPageOrder(pageOrder, pages) {
  return pageOrder || pages.map(function (page) {
    return page._id;
  });
};

/**
  *
  * Clean pageOrder
  *
  * 1. Remove any pageIds associated with a missing page.
  * 2. Remove any underfined or invalid pageIds
  * 3. Remove any duplicate pageIds
  *
  * @param {Array} pageOrder //[string, string, ...]
  * @param {Array} pages //[object, object, ...]
  * @returns {Array}
*/
var cleanPageOrder = exports.cleanPageOrder = function cleanPageOrder(pageOrder, pages) {
  var pageLookup = {};
  pages.forEach(function (page) {
    return pageLookup[page._id] = page && !page.deleted;
  });
  return pageOrder.filter(function (pageId, index) {
    return pageLookup[pageId] && pageId && pageOrder.indexOf(pageId) === index;
  });
};

/**
 * Sort pages based on pageOrder
 */
var sortPages = exports.sortPages = function sortPages(pages, pageOrder) {
  if (!pageOrder) return pages;
  var pageLookup = {};
  pages.forEach(function (page) {
    pageLookup[page._id] = page;
  });
  var sortedPages = [];
  pageOrder.forEach(function (pageId) {
    if (pageLookup[pageId]) sortedPages.push(pageLookup[pageId]);
  });
  return sortedPages;
};

/**
 * Get a properly formatted Document JoyDoc
 *
 * @returns {Object}
 */
var getDefaultDocument = exports.getDefaultDocument = function getDefaultDocument() {
  var type = _DocumentTypes["default"].document;
  var _id = (0, _generateObjectId["default"])();
  var identifier = "doc_".concat(_id);
  var name = 'New Doc';
  return getDefaultJoyDoc({
    type: type,
    _id: _id,
    identifier: identifier,
    name: name
  });
};

/**
 * Get a properly formatted Template JoyDoc
 *
 * @returns {Object}
 */
var getDefaultTemplate = exports.getDefaultTemplate = function getDefaultTemplate() {
  var type = _DocumentTypes["default"].template;
  var _id = (0, _generateObjectId["default"])();
  var identifier = "template_".concat(_id);
  var name = 'New Template';
  return getDefaultJoyDoc({
    type: type,
    _id: _id,
    identifier: identifier,
    name: name
  });
};

/**
 * Get a properly formatted duplicate of a Template or Document
 *
 * @returns {Object}
 */
var duplicate = exports.duplicate = function duplicate(original, defaults) {
  //Remove all references to original template object
  var origin = JSON.parse(JSON.stringify(original));
  var _id = (0, _generateObjectId["default"])();
  var identifier = origin.type === _DocumentTypes["default"].template ? "template_".concat(_id) : "doc_".concat(_id);
  return _objectSpread(_objectSpread({}, origin), {}, {
    _id: _id,
    identifier: identifier,
    createdOn: new Date().getTime(),
    source: origin.identifier
  }, defaults);
};

/**
 * Get a properly formatted Document JoyDoc from Template JoyDoc
 *
 * @param {Object} template
 * @returns {Object}
 */
var getDocumentFromTemplate = exports.getDocumentFromTemplate = function getDocumentFromTemplate(template) {
  var _id = (0, _generateObjectId["default"])();
  var identifier = "doc_".concat(_id);

  //Remove all references to original template object
  var temp = JSON.parse(JSON.stringify(template));
  return {
    _id: _id,
    identifier: identifier,
    type: _DocumentTypes["default"].document,
    name: temp.name,
    template: temp.identifier,
    source: temp.identifier,
    files: temp.files,
    fields: temp.fields
  };
};

/**
 * Handle Page Duplication for JoyDoc
 *
 * @param {Object} doc //Full JoyDoc Payload for Template or Document
 * @param {String} fileId //File ID that contains the page we are duplicating
 * @param {String} pageId
 * @param {Object} pageDefaults
 * @returns {Object}
 */
var duplicateDocumentPage = exports.duplicateDocumentPage = function duplicateDocumentPage(doc, fileId, pageId) {
  var _nextDoc$fields;
  var pageDefaults = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var changelogInfo = {
    primaryPages: {
      targetIndex: 0,
      page: null
    },
    viewPages: [],
    fields: []
  };
  var nextDoc = JSON.parse(JSON.stringify(doc));
  var fileIndex = nextDoc.files.findIndex(function (file) {
    return file._id === fileId;
  });
  var newPageId = (0, _generateObjectId["default"])();
  var fieldLookup = {};
  (_nextDoc$fields = nextDoc.fields) === null || _nextDoc$fields === void 0 ? void 0 : _nextDoc$fields.forEach(function (field) {
    if (field.file === fileId) fieldLookup[field._id] = field;
  });

  /**
   * Step 1: Duplicate fields associated with target page
   */
  var fieldIdsToDuplicate = [];

  //Step 1.1 Get all field Ids from primary page
  var targetPageIndex = nextDoc.files[fileIndex].pages.findIndex(function (page) {
    return page._id === pageId;
  });
  if (targetPageIndex !== -1) nextDoc.files[fileIndex].pages[targetPageIndex].fieldPositions.forEach(function (fieldPosition) {
    return fieldIdsToDuplicate.push(fieldPosition.field);
  });

  //Step 1.2 Get all field Ids from view page
  if (nextDoc.files[fileIndex].views && nextDoc.files[fileIndex].views.length > 0) {
    nextDoc.files[fileIndex].views.forEach(function (view) {
      var viewPageIndex = view.pages.findIndex(function (page) {
        return page._id === pageId;
      });
      if (viewPageIndex !== -1) {
        view.pages[viewPageIndex].fieldPositions.forEach(function (fieldPosition) {
          if (fieldIdsToDuplicate.indexOf(fieldPosition.field) === -1) fieldIdsToDuplicate.push(fieldPosition.field);
        });
      }
    });
  }
  var newFieldsLookupByOldId = {};
  var duplicatedFields = [];
  fieldIdsToDuplicate.forEach(function (fieldId) {
    /**
     * Why do we check if a new field has already been created?
     *
     * That is because multiple field positions can be associated with the same
     * field. If a field has already been created by a previous field position
     * that is linked to the same field as the current target then do not create
     * again.
     */
    if (newFieldsLookupByOldId[fieldId]) return;
    var field = fieldLookup[fieldId];
    var duplicateField = _objectSpread(_objectSpread({}, field), {}, {
      _id: (0, _generateObjectId["default"])()
    });
    duplicatedFields.push(duplicateField);

    /**
     * Add to lookup so it can be used with other associated field positions
     */
    newFieldsLookupByOldId[field._id] = duplicateField;
  });

  /**
   * Step 2: Update newly duplicated fields logic properties
   *
   * This step can only be done after all fields have been properly duplicated.
   *
   * We only need to update logic conditions that referenced the target page
   * that we are duplicating. We do this by checking the logic.condition[x].page
   * property of the condition.
   */
  duplicatedFields = duplicatedFields.map(function (duplicatedField) {
    if (!duplicatedField.logic || !duplicatedField.logic.conditions || duplicatedField.logic.conditions.length < 1) return duplicatedField;
    var nextField = _objectSpread(_objectSpread({}, duplicatedField), {}, {
      logic: _objectSpread({}, duplicatedField.logic)
    });
    nextField.logic.conditions = nextField.logic.conditions.map(function (condition) {
      /**
       * 1. Only update conditions associated with the current page being duplicated.
       * 2. Only update conditions associated with a field that was duplicated.
       */
      if (condition.page === pageId && newFieldsLookupByOldId[condition.field]) {
        return _objectSpread(_objectSpread({}, condition), {}, {
          page: newPageId,
          field: newFieldsLookupByOldId[condition.field]._id
        });
      } else {
        return condition;
      }
    });
    return nextField;
  });

  /**
   * Step 3: Add newly duplicated fields changelogs and update doucment
   */
  duplicatedFields.forEach(function (duplicateField) {
    changelogInfo.fields.push(duplicateField);
    nextDoc.fields.push(duplicateField);
  });

  /**
   * Step 4: Update Primary View Page Order
   *
   * IMPORTANT NOTE: Page order update must go before page object creation.
   */
  var pageOrder = getPageOrder(nextDoc.files[fileIndex].pageOrder, nextDoc.files[fileIndex].pages);
  var primaryPageOrderIndex = pageOrder.findIndex(function (id) {
    return id === pageId;
  });
  var primaryPageOrderTargetIndex = primaryPageOrderIndex + 1;
  nextDoc.files[fileIndex].pageOrder = pageOrder;
  nextDoc.files[fileIndex].pageOrder.splice(primaryPageOrderTargetIndex, 0, newPageId);

  /**
   * Step 5: Generate Primary View Page
   */
  var primaryPageIndex = nextDoc.files[fileIndex].pages.findIndex(function (page) {
    return page._id === pageId;
  });
  var newPrimaryPage = primaryPageIndex === -1 ? null : _objectSpread(_objectSpread({}, nextDoc.files[fileIndex].pages[primaryPageIndex]), {}, {
    _id: newPageId,
    fieldPositions: []
  }, pageDefaults);
  nextDoc.files[fileIndex].pages[primaryPageIndex].fieldPositions.forEach(function (fieldPosition) {
    var newField = newFieldsLookupByOldId[fieldPosition.field];
    newPrimaryPage.fieldPositions.push(_objectSpread(_objectSpread({}, fieldPosition), {}, {
      field: newField._id
    }));
  });
  nextDoc.files[fileIndex].pages.splice(primaryPageIndex + 1, 0, newPrimaryPage);

  /**
   * Step 6: Update Primary Page Changelog
   */
  changelogInfo.primaryPages.targetIndex = primaryPageOrderTargetIndex;
  changelogInfo.primaryPages.page = newPrimaryPage;

  /**
   * Step 7: Update Views
   */
  if (nextDoc.files[fileIndex].views && nextDoc.files[fileIndex].views.length > 0) {
    nextDoc.files[fileIndex].views = nextDoc.files[fileIndex].views.map(function (view) {
      var nextView = _objectSpread({}, view);
      var viewPageIndex = nextView.pages.findIndex(function (page) {
        return page._id === pageId;
      });
      if (viewPageIndex === -1) return view;

      /**
       * Step 7.1 Update View Page Order.
       *
       * IMPORTANT NOTE: Page order update must go before page object creation.
       */
      var nextViewPageOrder = getPageOrder(nextView.pageOrder, nextView.pages);
      var nextViewPageOrderIndex = nextViewPageOrder.findIndex(function (id) {
        return id === pageId;
      });
      var nextViewTargetPageOrderIndex = nextViewPageOrderIndex + 1;
      nextView.pageOrder = nextViewPageOrder;
      nextView.pageOrder.splice(nextViewTargetPageOrderIndex, 0, newPageId);

      /**
       * Step 7.2 Update View Pages
       */
      var newViewPage = _objectSpread(_objectSpread({}, nextView.pages[viewPageIndex]), {}, {
        _id: newPageId,
        fieldPositions: []
      }, pageDefaults);
      nextView.pages[viewPageIndex].fieldPositions.forEach(function (fieldPosition) {
        var newField = newFieldsLookupByOldId[fieldPosition.field];
        newViewPage.fieldPositions.push(_objectSpread(_objectSpread({}, fieldPosition), {}, {
          field: newField._id
        }));
      });
      nextView.pages.splice(viewPageIndex + 1, 0, newViewPage);

      /**
       * Step 7.3 Add View Page Changelog Info
       */
      changelogInfo.viewPages.push({
        viewId: view._id,
        view: view.type,
        targetIndex: nextViewTargetPageOrderIndex,
        page: newViewPage
      });
      return nextView;
    });
  }
  return {
    changelogInfo: changelogInfo,
    doc: nextDoc
  };
};

/**
 * Generate the mobile view and add specific mobile view properties
 *
 * @param {Object} file //Full file object
 * @returns {Object}
 */
var getMobileViewFromFile = exports.getMobileViewFromFile = function getMobileViewFromFile(file) {
  var _file$views2;
  var mobileViewIndex = file !== null && file !== void 0 && file.views && (file === null || file === void 0 ? void 0 : (_file$views2 = file.views) === null || _file$views2 === void 0 ? void 0 : _file$views2.length) > 0 ? file.views.findIndex(function (view) {
    return view.type === _FileViews["default"].mobile;
  }) : -1;
  if (mobileViewIndex !== -1) {
    /**
     * Why do we do this? Early versions of alternative views did not contain pageOrder so
     * we ensure it's populated here.
     */
    var mobileView = file.views[mobileViewIndex];
    var mobileViewPageOrder = cleanPageOrder(getPageOrder(mobileView.pageOrder, mobileView.pages), mobileView.pages);
    return _objectSpread(_objectSpread({}, mobileView), {}, {
      pageOrder: mobileViewPageOrder
    });
  } else {
    return generateMobileViewFromFile(file);
  }
};

/**
 * Generates the alternative mobile view from the default file view.
 *
 * @param {Object} file //Full file object
 * @returns {Object}
 */
var generateMobileViewFromFile = exports.generateMobileViewFromFile = function generateMobileViewFromFile(file) {
  var pages = file.pages || [];
  var pageOrder = cleanPageOrder(getPageOrder(file.pageOrder, file.pages), file.pages);
  return {
    _id: (0, _generateObjectId["default"])(),
    type: _FileViews["default"].mobile,
    pages: (0, _toConsumableArray2["default"])(pages).map(function (page) {
      var _id = page._id,
        name = page.name,
        identifier = page.identifier,
        fieldPositions = page.fieldPositions,
        rowHeight = page.rowHeight;
      return generateMobilePage({
        _id: _id,
        identifier: identifier,
        name: name,
        fieldPositions: fieldPositions,
        rowHeight: rowHeight
      });
    }),
    pageOrder: (0, _toConsumableArray2["default"])(pageOrder)
  };
};

/**
 * Apply the pr
 *
 * @param {Object} page
 * @returns {Objectg}
 */
var generateMobilePage = exports.generateMobilePage = function generateMobilePage(page) {
  return _objectSpread(_objectSpread({}, page), {}, {
    fieldPositions: page.fieldPositions ? generateMobilePageFieldPositions(page.fieldPositions, page.rowHeight) : [],
    type: _PageTypes["default"].mobile,
    rowHeight: 1,
    cols: 1,
    padding: 12,
    width: 816,
    height: 1056,
    layout: _PageLayoutModes["default"].grid,
    presentation: _FieldPresentationModes["default"].normal
  });
};
var generateMobilePageFieldPositions = exports.generateMobilePageFieldPositions = function generateMobilePageFieldPositions(fieldPositions, originalRowHeight) {
  var mobileFieldPositions = [];

  /**
   * Step 1: Sort fieldPositions
   */
  var sortedFieldPositions = sortFieldPositionsByXAndYCoordinates(fieldPositions);
  sortedFieldPositions.forEach(function (joySpecFieldPosition) {
    var mobileFieldPositionData = _objectSpread(_objectSpread({}, joySpecFieldPosition), {}, {
      titleDisplay: _FormStyleOptions["default"].displayInline,
      displayType: _FieldDisplayTypes["default"].original,
      height: joySpecFieldPosition.height * (originalRowHeight || 1),
      width: 1,
      x: 0
    });

    /**
     * Step 1.2 Hide chart lines on mobile
     */
    if (joySpecFieldPosition.type === _FieldTypes["default"].chart) mobileFieldPositionData.primaryDisplayOnly = true;
    mobileFieldPositions.push(mobileFieldPositionData);
  });
  return mergeAssoicatedFieldPositionsForMobilePage(mobileFieldPositions);
};

/**
 * Merge Field Positions assoicated with the same Field.
 *
 * Why do duplicate fields get created from fieldPositions
 *
 * The same field can get added twice because we may have multiple fieldPositions belonging
 * to the same field. This can happen with dropdown, multiSelect, and table fields.
 *
 * Since the fields get generated by looping over the fieldPositions and not regular fields
 * we may encounter the the same field multiple times because it has multiple fieldPositions.
 *
 * @param {Array} fields
 * @returns {Array}
 */
var mergeAssoicatedFieldPositionsForMobilePage = exports.mergeAssoicatedFieldPositionsForMobilePage = function mergeAssoicatedFieldPositionsForMobilePage(fieldPositions) {
  var filteredFieldPositions = [];
  fieldPositions === null || fieldPositions === void 0 ? void 0 : fieldPositions.forEach(function (fieldPosition) {
    var fieldPositionIndex = filteredFieldPositions.findIndex(function (filtered) {
      var _filtered$field, _fieldPosition$field;
      return (filtered === null || filtered === void 0 ? void 0 : (_filtered$field = filtered.field) === null || _filtered$field === void 0 ? void 0 : _filtered$field.toString()) === (fieldPosition === null || fieldPosition === void 0 ? void 0 : (_fieldPosition$field = fieldPosition.field) === null || _fieldPosition$field === void 0 ? void 0 : _fieldPosition$field.toString());
    });

    //Only add field to the list if it hasn't already been added
    if (fieldPositionIndex === -1) filteredFieldPositions.push(fieldPosition);
  });
  return filteredFieldPositions;
};

/**
 * Sort fields by their y and x coordinates
 *
 * For example:
 * [
 *   { "y": 3, "x": 4 },
 *   { "y": 3, "x": 1 },
 *   { "y": 2, "x": 0 },
 *   { "y": 1, "x": 5.22 },
 *   { "y": 1, "x": 10 },
 *   { "y": 1, "x": 0 },
 * ]
 * will become the following after sort
 * [
 *   { "y": 1, "x": 0 },
 *   { "y": 1, "x": 5.22 },
 *   { "y": 1, "x": 10 },
 *   { "y": 2, "x": 0 },
 *   { "y": 3, "x": 1 },
 *   { "y": 3, "x": 4 }
 * ];
 *
 * @param {Array} fieldPositions
 * @returns {Array}
 */
var sortFieldPositionsByXAndYCoordinates = exports.sortFieldPositionsByXAndYCoordinates = function sortFieldPositionsByXAndYCoordinates(fieldPositions) {
  var sortedFieldPositions = (0, _toConsumableArray2["default"])(fieldPositions);
  sortedFieldPositions.sort(function (a, b) {
    if (a.y === b.y) {
      return a.x - b.x;
    } else if (a.y > b.y) {
      return 1;
    } else if (a.y < b.y) {
      return -1;
    } else {
      return 0;
    }
  });
  return sortedFieldPositions;
};

/**
 * Formats individual table cell field positions that have already been merged with their associated field.
 * This additional information is added and used for rendering the fieldPositions on the form.
 *
 * For instance, adds properties like columnType, calculatedCellValue, options, etc.
 *
 * @param {Array} fieldPositions
 * @returns {Array}
 */
var formatTableFieldPositions = exports.formatTableFieldPositions = function formatTableFieldPositions(fieldPositions) {
  /**
   * We only want to generate the table value calculated lookup for each table field once.
   * We use these lookups because multiple table fieldPositions belonging to the same table
   * field will all use the same table value calculated lookup.
   */
  var tableFieldLookup = {};
  var nextFieldPositions = [];
  (0, _toConsumableArray2["default"])(fieldPositions).forEach(function (fieldPosition) {
    var nextFieldPosition = _objectSpread({}, fieldPosition);
    if (fieldPosition.type === _FieldTypes["default"].table) {
      var field = fieldPosition.field,
        column = fieldPosition.column,
        rowIndex = fieldPosition.rowIndex,
        tableColumns = fieldPosition.tableColumns,
        value = fieldPosition.value,
        rowOrder = fieldPosition.rowOrder,
        tableColumnOrder = fieldPosition.tableColumnOrder;

      /**
       * Step 1: Generate rows, rowOrder, tableColumns, etc. lookups for associated field. We only have to
       * do this once per-field. This increases performance if there are multiple form positions associated
       * with the same form.
       */
      if (!tableFieldLookup[field]) {
        /**
         * Step 1.1 Handle rows
         */
        var nextRows = (0, _tableHelper.getRows)(value);
        var nextRowOrder = (0, _tableHelper.getCleanedRowOrder)(rowOrder, nextRows);
        var nextSortedRows = (0, _tableHelper.sortRows)(nextRows, nextRowOrder);

        /**
         * Step 1.2 Handle columns
         */
        var nextTableColumnOrder = (0, _tableHelper.getCleanedColumnOrder)(tableColumnOrder, tableColumns);
        var nextSortedTableColumns = (0, _tableHelper.sortColumns)(tableColumns, nextTableColumnOrder);
        var nextTableColumns = (0, _tableHelper.getColumns)(nextSortedTableColumns);
        var nextTableColumnLookup = {};
        nextTableColumns.forEach(function (column) {
          return nextTableColumnLookup[column._id] = column;
        });

        /**
         * Step 1.3 Handle cell calculations
         */
        var calculatedValue = (0, _tableHelper.generateTableLookup)(nextSortedRows, nextSortedTableColumns);
        tableFieldLookup[field] = {
          value: nextSortedRows,
          rowOrder: nextRowOrder,
          tableColumns: nextTableColumns,
          tableColumnOrder: nextTableColumnOrder,
          tableColumnLookup: nextTableColumnLookup,
          calculatedValue: calculatedValue
        };
      }

      /**
       * Ensure each table field has a properly formatted properties
       */
      nextFieldPosition.value = tableFieldLookup[field].value;
      nextFieldPosition.rowOrder = tableFieldLookup[field].rowOrder;
      nextFieldPosition.tableColumns = tableFieldLookup[field].tableColumns;
      nextFieldPosition.tableColumnOrder = tableFieldLookup[field].tableColumnOrder;

      /**
       * Add calculated value lookup. For instance, { A1: '', B1: '', C1: '', ... }
       */
      nextFieldPosition.calculatedValue = tableFieldLookup[field].calculatedValue;

      /**
       * Individual Table Cell vs Entire Table
       *
       * Only add cellValue, calculatedCellValue, columnType, and column options to
       * individually mapped table cell fieldPositions. Regular table fields (entire table)
       * just simply use the fieldPositions.value parameter so we don't need the calculated
       * values, etc.
       *
       * We determine an individual table cell fieldPosition vs an entire table
       * fieldPosition by checking for column and rowIndex. Individual cells have
       * column and rowIndex but regular tables do not.
       *
       * Note:
       * rowIndex + 1 is used while calculating cell value since column operands
       * start from 1 instead of zero in the table lookups
       * (ie: [A1:{}, B1:{}] instead of [A0:{}, B0:{}])
       *
       * If tableRowIndex associated with a cell doesn't have a table row associated
       * with it (ie rows[rowIndex] is undefined) it means that particular row is deleted
       */
      if (tableFieldLookup[field] && column && typeof rowIndex === 'number') {
        var _tableFieldLookup$fie;
        /**
         * What is the difference between rowIndex and targetRowIndex?
         *
         * - The rowIndex on the fieldPosition is the saved index of where the rowId lives inside of the rowOrder.
         * - The targetRowIndex is the actual index of the row object inside the value (array of row data) of the field.
         *
         * We use the fieldPosition.rowIndex to get the rowId from the rowOrder. Then we use the rowId to locate
         * the assoicated row object data in the value property. The rowOrder and value (rows) do not follow the same
         * order. The rowOrder is updated when users insert rows, move rows up or down, etc. it manages where rows
         * are at in the list and how they should be rendered. This is why the rowIndex uses the rowOrder.
         */
        var targetColumn = tableFieldLookup[field].tableColumnLookup[column];
        var targetRowId = tableFieldLookup[field].rowOrder[rowIndex];
        var targetRowIndex = tableFieldLookup[field].value.findIndex(function (row) {
          return (row === null || row === void 0 ? void 0 : row._id) === targetRowId;
        });

        /**
         * Add proper rowId to the field position so that it can be used
         * inside the element for change handlers;
         */
        nextFieldPosition.rowId = targetRowId;

        /**
         * If rows[rowIndex] is undefined, it means the row that was present
         * at the particular rowIndex was deleted
        */
        nextFieldPosition.cellValue = ((_tableFieldLookup$fie = tableFieldLookup[field].value[targetRowIndex]) === null || _tableFieldLookup$fie === void 0 ? void 0 : _tableFieldLookup$fie.cells[column]) || '';

        /**
         * Skip any individual field position that is associated with a deleted column.
         * targetColumn will appear as undefined if a column is deleted
         */
        if (targetColumn) {
          nextFieldPosition.calculatedCellValue = tableFieldLookup[field].calculatedValue["".concat(targetColumn.operand).concat(targetRowIndex + 1)];
          nextFieldPosition.columnType = targetColumn.type;
          nextFieldPosition.options = targetColumn.options;
          nextFieldPosition.columnIdentifier = targetColumn.identifier;

          /**
           * IMPORTANT NOTE: We only add individual table cell field position into
           * the fieldPosition list if the associated column is not deleted.
           */
          nextFieldPositions.push(nextFieldPosition);
        }
      } else {
        //Push table fields with original display type
        nextFieldPositions.push(nextFieldPosition);
      }
    } else {
      //Push other fields
      nextFieldPositions.push(nextFieldPosition);
    }
  });
  return nextFieldPositions;
};
var _default = exports["default"] = {
  getDefaultJoyDocPage: getDefaultJoyDocPage,
  getDefaultJoyDocFile: getDefaultJoyDocFile,
  getDefaultJoyDoc: getDefaultJoyDoc,
  getCleanedJoyDoc: getCleanedJoyDoc,
  getCleanedJoyDocPages: getCleanedJoyDocPages,
  getDefaultDocument: getDefaultDocument,
  getDefaultTemplate: getDefaultTemplate,
  getDocumentFromTemplate: getDocumentFromTemplate,
  duplicate: duplicate,
  duplicateDocumentPage: duplicateDocumentPage,
  getPageOrder: getPageOrder,
  sortPages: sortPages,
  sortFieldPositionsByXAndYCoordinates: sortFieldPositionsByXAndYCoordinates,
  mergeAssoicatedFieldPositionsForMobilePage: mergeAssoicatedFieldPositionsForMobilePage,
  generateMobileViewFromFile: generateMobileViewFromFile,
  generateMobilePage: generateMobilePage,
  generateMobilePageFieldPositions: generateMobilePageFieldPositions,
  formatTableFieldPositions: formatTableFieldPositions
};