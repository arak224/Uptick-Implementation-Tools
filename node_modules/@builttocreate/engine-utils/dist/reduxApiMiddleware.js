"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.CALL_API = void 0;
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2["default"])(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
var CALL_API = exports.CALL_API = 'CALL API';
var callApiMiddleware = function callApiMiddleware(_ref) {
  var dispatch = _ref.dispatch,
    getState = _ref.getState;
  /**
   * @param next //Callback for the action
   * @param action //Action object
   *
   * async action example: {
   *   CALL_API: {
   *     types: [ACTION_REQUEST, ACTION_SUCCESS, ACTION_FAILURE],
   *     apiCall: apiMethodCall, //apiMethodCall should return a promise
   *     success: callbackFunction,
   *     error: callbackFunction
   *   }
   * }
   */
  return function (next) {
    return function (action) {
      var callApi = action[CALL_API];

      //If callApi is not defined then it is a normal action (synchronous) pass it through
      if (typeof callApi === 'undefined') return next(action);
      var types = callApi.types,
        apiCall = callApi.apiCall;
      var successCallback = callApi.success;
      var errorCallback = callApi.error;

      /**
       * Action validation
       *
       * Types:
       * All async actions should have three action types: requested, success, & failure
       * All actions should be strings.
       *
       * apiCall:
       * All aysnc actions should have an apiCall function
       */

      if (!Array.isArray(types) || types.length !== 3) {
        throw new Error('action.types: Expected an array of three action types');
      }
      if (!types.every(function (type) {
        return typeof type === 'string';
      })) {
        throw new Error('action.types: Expected action types to be strings');
      }
      if (typeof apiCall !== 'function') {
        throw new Error('action.apiCall: Expected apiCall to be a function');
      }
      var actionWith = function actionWith(data) {
        var finalAction = _objectSpread(_objectSpread({}, action), data);
        delete finalAction[CALL_API];
        return finalAction;
      };
      var _callApi$types = (0, _slicedToArray2["default"])(callApi.types, 3),
        requestType = _callApi$types[0],
        successType = _callApi$types[1],
        failureType = _callApi$types[2];
      next(actionWith({
        type: requestType
      }));
      return apiCall().then(function (response) {
        next(actionWith({
          type: successType,
          payload: response
        }));
        if (successCallback) successCallback(response, dispatch, getState);
      })["catch"](function (error) {
        next(actionWith({
          type: failureType,
          payload: error,
          error: true
        }));
        if (errorCallback) errorCallback(error, dispatch, getState);
      });
    };
  };
};
var _default = exports["default"] = callApiMiddleware;