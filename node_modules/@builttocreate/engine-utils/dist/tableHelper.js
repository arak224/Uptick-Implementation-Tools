"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof3 = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validFormulaString = exports.spreadOperandRange = exports.sortRows = exports.sortColumns = exports.resolveOperandValue = exports.hasOperandRange = exports.hasCircularOperandReference = exports.handleTableCellChange = exports.handleMoveTableRowUp = exports.handleMoveTableRowDown = exports.handleMoveColumnRight = exports.handleMoveColumnLeft = exports.handleInsertTableRow = exports.handleDuplicateTableRow = exports.handleCreateTableRow = exports.getTemplateColumnOperandLookup = exports.getTargetColumnWithOperand = exports.getTableRowLookupWithPopulatedDropdownCells = exports.getTableFieldRowOrder = exports.getTableFieldLookupKey = exports.getRows = exports.getRowOrder = exports.getRowMap = exports.getRowIndexLookup = exports.getInputGroupRowLookupWithPopulatedDropdownCells = exports.getIndexesFromTableCellOperand = exports.getFormulaResult = exports.getFilteredRowOrder = exports.getDefaultTextColumn = exports.getDefaultRow = exports.getDefaultImageColumn = exports.getDefaultDropdownColumn = exports.getDefaultColumnOption = exports.getColumns = exports.getColumnOrder = exports.getColumnOperand = exports.getCleanedRowOrder = exports.getCleanedColumnOrder = exports.getCellOperand = exports.generateTableLookupForRows = exports.generateTableLookup = exports.generateTableFieldLookups = exports.generateRowTableLookup = exports.generateInputGroupFields = exports["default"] = void 0;
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _hotFormulaParser = require("@builttocreate/hot-formula-parser");
var _generateObjectId = _interopRequireDefault(require("./generateObjectId"));
var _Table = _interopRequireWildcard(require("./constants/Table"));
var _FieldTypes = _interopRequireDefault(require("./constants/FieldTypes"));
var _FieldTableColumnTypes = _interopRequireDefault(require("./constants/FieldTableColumnTypes"));
var _FieldTableCustomColumnIds = _interopRequireDefault(require("./constants/FieldTableCustomColumnIds"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != _typeof3(e) && "function" != typeof e) return { "default": e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) { if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } } return n["default"] = e, t && t.set(e, n), n; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2["default"])(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
var parser = new _hotFormulaParser.Parser();
var getTableFieldLookupKey = exports.getTableFieldLookupKey = function getTableFieldLookupKey(fieldId, rowIndex, columnId) {
  return "".concat(fieldId, "-").concat(rowIndex, "-").concat(columnId);
};
var getDefaultRow = exports.getDefaultRow = function getDefaultRow() {
  return {
    _id: (0, _generateObjectId["default"])(),
    deleted: false,
    cells: {}
  };
};
var getRows = exports.getRows = function getRows(rows) {
  var parsedRows = rows;
  if (typeof parsedRows === 'string') {
    parsedRows = JSON.parse(parsedRows);
  }
  return parsedRows ? parsedRows.filter(function (row) {
    return !row.deleted;
  }) : [];
};

/**
 * Sort rows based on rowOrder
 */
var sortRows = exports.sortRows = function sortRows(rows, rowOrder) {
  if (!rowOrder) return rows;
  var rowLookup = {};
  rows.forEach(function (row) {
    rowLookup[row._id] = row;
  });
  var sortedRows = [];
  rowOrder.forEach(function (rowId) {
    if (rowLookup[rowId]) sortedRows.push(rowLookup[rowId]);
  });
  return sortedRows;
};

/**
 * Filter table row order by cell values
 *
 * @param {Array} rowOrder
 * @param {Array} rows
 * @param {Object} filters //{ colId: value, colId: value, ....}
 */
var getFilteredRowOrder = exports.getFilteredRowOrder = function getFilteredRowOrder(rowOrder, rows, filters) {
  var filteredColumnIds = filters ? Object.keys(filters) : [];
  var validRowOrder = rowOrder;
  if (!validRowOrder) {
    var validRows = rows ? getRows(rows) : [];
    validRowOrder = validRows.map(function (row) {
      return row._id;
    });
  }

  /**
   * Remove any duplicate rowIds. We have had instances where
   * users encounter duplicate rowIds in the rowOrder.
   * See: https://github.com/zionlabs/Issues/issues/1589
   */
  var cleanedValidRowOrder = [];
  validRowOrder.forEach(function (rowId) {
    if (cleanedValidRowOrder.indexOf(rowId) === -1) cleanedValidRowOrder.push(rowId);
  });
  if (filteredColumnIds.length > 0) {
    var matchedRows = {};
    rows.forEach(function (row) {
      if (row.deleted) return;
      var rowMatched = true;
      filteredColumnIds.forEach(function (columnId) {
        var filter = filters[columnId] ? filters[columnId].toLowerCase() : '';
        var value = row.cells && row.cells[columnId] ? row.cells[columnId].toLowerCase() : '';
        if (filter && (!value || value.indexOf(filter) === -1)) rowMatched = false;
      });
      if (rowMatched) matchedRows[row._id] = true;
    });
    return cleanedValidRowOrder.filter(function (rowId) {
      return matchedRows[rowId];
    });
  } else {
    return cleanedValidRowOrder;
  }
};

/**
 * Create a table row map for simple value lookup
 *
 * For instance:
 * {
 *    rowId: {columnId: value, columnId: value, ...},
 *    rowId: {columnId: value, columnId: value, ...},
 *    rowId: {columnId: value, columnId: value, ...}
 * }
 *
 * @param {Array} rows
 * @return {Object}
 */
var getRowMap = exports.getRowMap = function getRowMap() {
  var rows = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var items = getRows(rows);
  var rowMap = {};
  items.forEach(function (row) {
    return rowMap[row._id] = row.cells || {};
  });
  return rowMap;
};

/**
 * Get row order
 *
 * @param {Array} rows
 * @param {Array} rowOrder
 *
 * @return {Array}
 */
var getRowOrder = exports.getRowOrder = function getRowOrder(rowOrder, rows) {
  return rowOrder || getRows(rows).map(function (row) {
    return row._id;
  });
};

/**
 * Get row order for table field. If there isn't a row order set in the
 * fieldSettings then it will default to the normal row array Ids.
 *
 * @param {String} fieldId
 * @param {Object} fieldSettings
 * @param {Array} rows
 *
 * @return {Array}
 */
var getTableFieldRowOrder = exports.getTableFieldRowOrder = function getTableFieldRowOrder(fieldId, fieldSettings, rows) {
  var filteredRows = rows ? getRows(rows) : [];
  return fieldSettings && fieldSettings[fieldId] && fieldSettings[fieldId].rowOrder ? (0, _toConsumableArray2["default"])(fieldSettings[fieldId].rowOrder) : filteredRows.map(function (row) {
    return row._id;
  });
};

/**
 * This method removes the rowIds of the deleted rows (or) any duplicate rowIds
 * from the rowOrder there by returning a cleaned rowOrder
 * @param {*} rowOrder
 * @param {*} rows
 *
 * @returns {Array}
**/
var getCleanedRowOrder = exports.getCleanedRowOrder = function getCleanedRowOrder(rowOrder, rows) {
  var nextRowOrder = [];

  /**
   * Step 1: Handle generating or retrieving proper row order.
   */
  if (rowOrder && rowOrder.length > 0) {
    nextRowOrder = rowOrder;
  } else if (rows && rows.length > 0) {
    rows.forEach(function (row) {
      if (!row.deleted) nextRowOrder.push(row._id);
    });
  }

  /**
   * Step 2: Remove row Ids from rowOrder for rows that no longer exist or have been deleted
   */
  var rowLookup = {};
  rows.forEach(function (row) {
    return rowLookup[row._id] = row && !row.deleted;
  });
  nextRowOrder = nextRowOrder.filter(function (rowId) {
    return rowLookup[rowId];
  });

  /**
   * Step 3: Remove any duplicate row Id references in the row order.
   */
  var filteredNextRowOrder = [];
  nextRowOrder.forEach(function (rowId) {
    if (rowId && filteredNextRowOrder.indexOf(rowId) === -1) filteredNextRowOrder.push(rowId);
  });
  return filteredNextRowOrder;
};

/**
 * Handle Move Column Left
 *
 * @param {Number} columnIndex
 * @param {Func} callback
 */
var handleMoveColumnLeft = exports.handleMoveColumnLeft = function handleMoveColumnLeft(columnIndex, callback) {
  //If first index then ignore
  if (columnIndex === 0) return;
  var targetIndex = columnIndex - 1;
  if (callback) callback({
    targetIndex: targetIndex
  });
};

/**
 * Handle Move Column Right
 *
 * @param {Array} columns
 * @param {Number} columnIndex
 * @param {Func} callback
 */
var handleMoveColumnRight = exports.handleMoveColumnRight = function handleMoveColumnRight(columns, columnIndex, callback) {
  //If last column index then ignore
  if (columnIndex >= columns.length - 1) return;
  var targetIndex = columnIndex + 1;
  if (callback) callback({
    targetIndex: targetIndex
  });
};

/**
 * Get default column option
 *
 * @param {String} value
 * @return {Object}
 */
var getDefaultColumnOption = exports.getDefaultColumnOption = function getDefaultColumnOption(value) {
  return {
    _id: (0, _generateObjectId["default"])(),
    value: value || 'Option',
    deleted: false
  };
};

/**
 * Get default text column for table field
 *
 * @param {Object} defaults //Overwrite any values with this defaults object
 *
 * @return {Object}
 */
var getDefaultTextColumn = exports.getDefaultTextColumn = function getDefaultTextColumn() {
  var defaults = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return _objectSpread({
    _id: (0, _generateObjectId["default"])(),
    type: _FieldTableColumnTypes["default"].text,
    title: 'Text Column',
    width: 200,
    deleted: false
  }, defaults);
};

/**
 * Get default dropdown column for table field
 *
 * @param {Object} defaults //Overwrite any values with this defaults object
 *
 * @return {Object}
 */
var getDefaultImageColumn = exports.getDefaultImageColumn = function getDefaultImageColumn() {
  var defaults = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return _objectSpread({
    _id: (0, _generateObjectId["default"])(),
    type: _FieldTableColumnTypes["default"].image,
    title: 'Image Column',
    deleted: false,
    width: 200,
    maxImageWidth: 190,
    maxImageHeight: 120
  }, defaults);
};

/**
 * Get default dropdown column for table field
 *
 * @param {Object} defaults //Overwrite any values with this defaults object
 *
 * @return {Object}
 */
var getDefaultDropdownColumn = exports.getDefaultDropdownColumn = function getDefaultDropdownColumn() {
  var defaults = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var options = defaults.options || [getDefaultColumnOption('Yes'), getDefaultColumnOption('No'), getDefaultColumnOption('N/A')];
  return _objectSpread({
    _id: (0, _generateObjectId["default"])(),
    type: _FieldTableColumnTypes["default"].dropdown,
    title: 'Dropdown Column',
    deleted: false,
    width: 200,
    options: options,
    optionOrder: options.map(function (option) {
      return option._id;
    })
  }, defaults);
};

/**
 * Get column order
 *
 * @param {Array} columns
 * @param {Array} columnOrder
 *
 * @return {Array}
 */
var getColumnOrder = exports.getColumnOrder = function getColumnOrder(columnOrder, columns) {
  return columnOrder || getColumns(columns).map(function (column) {
    return column._id;
  });
};

/**
 * This method removes the columnIds of the deleted columns (or) any duplicate columnIds
 * from the tableColumnOrder there by returning a cleaned tableColumnOrder
 *
 * @param {*} tableColumnOrder
 * @param {*} tableColumns
 *
 * @returns {Array}
**/
var getCleanedColumnOrder = exports.getCleanedColumnOrder = function getCleanedColumnOrder(columnOrder, columns) {
  var nextColumnOrder = [];

  /**
   * Step 1: Handle generating or retrieving proper column order.
   */
  if (columnOrder && columnOrder.length > 0) {
    nextColumnOrder = columnOrder;
  } else if (columns && columns.length > 0) {
    columns.forEach(function (column) {
      if (!column.deleted) nextColumnOrder.push(column._id);
    });
  }

  /**
   * Step 2: Remove column Ids from columnOrder for columns that no longer exist or have been deleted
   */
  var columnLookup = {};
  columns.forEach(function (column) {
    return columnLookup[column._id] = column && !column.deleted;
  });
  nextColumnOrder = nextColumnOrder.filter(function (columnId) {
    return columnLookup[columnId];
  });

  /**
   * Step 3: Remove any duplicate column Id references in the column order.
   */
  var filteredNextColumnOrder = [];
  nextColumnOrder.forEach(function (columnId) {
    if (columnId && filteredNextColumnOrder.indexOf(columnId) === -1) filteredNextColumnOrder.push(columnId);
  });
  return filteredNextColumnOrder;
};

/**
 * Get table columns with added operands. Operands are the A, B, C, etc.
 */
var getColumns = exports.getColumns = function getColumns(columns) {
  var parsedColumns = columns;
  if (typeof parsedColumns === 'string') {
    parsedColumns = JSON.parse(parsedColumns);
  }
  return !parsedColumns ? [] : parsedColumns.filter(function (column) {
    return !column.deleted;
  }).map(function (column, i) {
    var nextColumn = _objectSpread({}, column);
    nextColumn.operand = getColumnOperand(i);
    return nextColumn;
  });
};

/**
 * Sort columns based on columnOrder
 */
var sortColumns = exports.sortColumns = function sortColumns(columns, columnOrder) {
  if (!columnOrder) return columns;
  var columnLookup = {};
  columns.forEach(function (col) {
    columnLookup[col._id] = col;
  });
  var sortedColumns = [];
  columnOrder.forEach(function (colId) {
    if (columnLookup[colId]) sortedColumns.push(columnLookup[colId]);
  });
  return sortedColumns;
};

/**
 * Get the targetColumn with added operand. Operands are A, B ,C etc...
 */
var getTargetColumnWithOperand = exports.getTargetColumnWithOperand = function getTargetColumnWithOperand(columnOrder, columns, columnId) {
  var targetColumn = columns.find(function (col) {
    return col._id === columnId;
  });
  var nextTargetColumn = _objectSpread({}, targetColumn);
  var targetColumnIndex = columnOrder.findIndex(function (item) {
    return item === targetColumn._id;
  });
  var targetColumnOperand = getColumnOperand(targetColumnIndex);
  nextTargetColumn.operand = targetColumnOperand;
  return nextTargetColumn;
};

/**
 * Return letter for a column index. For intance: A, B, C
 *
 * Used to create the table lookup operands: A1, B12, etc.
 */
var getColumnOperand = exports.getColumnOperand = function getColumnOperand(index) {
  return String.fromCharCode(65 + index);
};

/**
 * Return rowIndex and columnIndex for cellOperand
 *
 * Operand examples: A1, B12, etc.
 *
 * @param {String} cellOperand
 * @returns {Object}
 */
var getIndexesFromTableCellOperand = exports.getIndexesFromTableCellOperand = function getIndexesFromTableCellOperand(cellOperand) {
  var letter = cellOperand.match(/[A-Z]*/gi).find(function (value) {
    return value;
  });
  var rowIndex = cellOperand.match(/[0-9]*/gi).find(function (value) {
    return value;
  });
  return {
    columnIndex: _Table.operandLetterIndexes[letter],
    /**
     * Cell operands start at an index of 1. So to get the true
     * index for the rowIndex we need to substract 1 so we can
     * use a 0 based index.
     */
    rowIndex: rowIndex - 1
  };
};

/**
 * Get operand lookup for all table/inputGroup fields in a template.
 *
 * For instance: {
 *   fieldId: { colId: 'A', colId: 'B', ...},
 *   ....
 * }
 */
var getTemplateColumnOperandLookup = exports.getTemplateColumnOperandLookup = function getTemplateColumnOperandLookup(template) {
  var operandLookup = {};
  template.fields.forEach(function (field) {
    if (field.type !== _FieldTypes["default"].table && field.type !== _FieldTypes["default"].inputGroup) return;
    if (!operandLookup[field._id]) operandLookup[field._id] = {};
    var columns = getColumns(field.tableColumns);
    columns.forEach(function (col, colIndex) {
      operandLookup[field._id][col._id] = getColumnOperand(colIndex);
    });
  });
  return operandLookup;
};

/**
 * Return operand for cell. For intance: A1, B2, C1
 *
 * @param {String} columnOperand //A, B, C, etc.
 * @param {Number} rowIndex
 */
var getCellOperand = exports.getCellOperand = function getCellOperand(columnOperand, rowIndex) {
  return "".concat(columnOperand).concat(rowIndex);
};

/**
 * Generate table lookup by rowIndex and column operand
 *
 * For instance:
 * {
 *    rowIndex: {A1: value, B1: value, ...},
 *    rowIndex: {A2: value, B2: value, ...},
 *    rowIndex: {A3: value, B3: value, ...},
 *    ...
 * }
 *
 * @param {Array} rows
 * @param {Array} columns
 * @param {Object} tableLookup
 *
 * @return {Object}

 */
var generateRowTableLookup = exports.generateRowTableLookup = function generateRowTableLookup(rows, columns, tableLookup) {
  if (!rows || !columns || !tableLookup) return {};
  var rowTableLookup = {};
  rows.forEach(function (row, rowIndex) {
    rowTableLookup[rowIndex] = {};
    columns.forEach(function (column, columnIndex) {
      var operand = getColumnOperand(columnIndex);
      var cellOperand = getCellOperand(operand, rowIndex + 1);
      rowTableLookup[rowIndex][cellOperand] = tableLookup[cellOperand];
    });
  });
  return rowTableLookup;
};

/**
 * Generate table lookups for each table field in template. It takes
 * all table & inputGroup fields and generates a table lookup object for them.
 *
 * For instance if you have a template and doc like the ones below:
 *
 * template: {
 *   fields: [
 *     {_id: textFieldId, ...},
 *     {_id: tableFieldId1, ...},
 *     {_id: tableFieldId2, ...},
 *     {_id: numberFieldId, ...},
 *     ...
 *   ]
 * }
 *
 * returned object would be: {
 *   tableFieldId1: { A1: value, B1: value, ...},
 *   tableFieldId2: { A2: value, B2: value, ...},
 *   ...
 * }
 */
var generateTableFieldLookups = exports.generateTableFieldLookups = function generateTableFieldLookups(doc, template) {
  var tableFields = template.fields.filter(function (field) {
    return (field.type === _FieldTypes["default"].table || field.type === _FieldTypes["default"].inputGroup) && !field.deleted;
  });
  var tableLookups = {};
  tableFields.forEach(function (field) {
    var docValue = doc.fields[field._id];
    var rows = getRows(docValue);
    var columns = getColumns(field.tableColumns);
    var docFieldSettings = doc.fieldSettings || {};
    var fieldSettings = docFieldSettings[field._id] || {};
    var rowOrder = fieldSettings.rowOrder && fieldSettings.rowOrder.length !== 0 ? fieldSettings.rowOrder : rows.map(function (row) {
      return row._id;
    });
    var validRows = sortRows(rows, rowOrder);
    tableLookups[field._id] = generateTableLookup(validRows, columns);
  });
  return tableLookups;
};

/**
 * Organize the table lookup on a row by row basis
 * @param {Array} rows
 * @param {Array} columns
 * @retuns {Object}
 *
 * Example return object:
 * {
 *   1: {
 *     A1: 12,
 *     B1: 1,
 *   },
 *   2: {
 *     A2: 10,
 *     B2: 4,
 *   },
 *   ...
 * }
 *
 */
var generateTableLookupForRows = exports.generateTableLookupForRows = function generateTableLookupForRows(rows, columns) {
  var tableLookup = generateTableLookup(rows, columns);
  var rowLookup = {};
  Object.keys(tableLookup).forEach(function (key) {
    var rowIndex = key.match(/[0-9]*/gi).find(function (value) {
      return value;
    });
    if (!rowLookup[rowIndex]) rowLookup[rowIndex] = {};
    rowLookup[rowIndex][key] = tableLookup[key];
  });
  return rowLookup;
};

/**
 * Generate Lookup Operand Lookup Table for Table Data. Supports converting
 * formula cells to the calculated value.
 *
 * Operand examples: A1, B12, C25, etc.
 *
 * @param {Array} rows
 * @param {Array} columns
 * @retuns {Object}
 *
 * Example return object:
 * {
 *   A1: 12,
 *   B1: 1,
 *   A2: 2,
 *   B2: 4,
 * }
 */
var generateTableLookup = exports.generateTableLookup = function generateTableLookup(rows, columns) {
  var tableLookup = {};
  var columnOptionsLookup = {};
  var tableColumns = [];
  var filteredColumns = columns.filter(function (column) {
    return !column.deleted //Used by both web and mobile
    && column._id !== _FieldTableCustomColumnIds["default"].rowMenu //Used on mobile
    && column._id !== _FieldTableCustomColumnIds["default"].rowNumber; //Used on mobile
  });
  filteredColumns.forEach(function (column, i) {
    var nextColumn = _objectSpread({}, column);
    nextColumn.operand = String.fromCharCode(65 + i);
    tableColumns.push(nextColumn);
    if (column.type === _FieldTableColumnTypes["default"].dropdown) {
      columnOptionsLookup[column._id] = {};
      column.options.forEach(function (option) {
        columnOptionsLookup[column._id][option._id] = option.value;
      });
    }
  });
  var parsedRows = typeof rows === 'string' ? JSON.parse(rows) : rows;
  var tableRows = parsedRows.filter(function (row) {
    return !row.deleted;
  });
  var formulaCells = [];
  tableRows.forEach(function (row, rowIndex) {
    tableColumns.forEach(function (column) {
      if (!column.operand) return;
      var cellKey = "".concat(column.operand).concat(rowIndex + 1);
      var cellRawValue = row.cells[column._id] ? row.cells[column._id] : undefined;
      var cellValue;
      if (cellRawValue && typeof cellRawValue === 'string') cellValue = cellRawValue.trim();
      if (cellRawValue && typeof cellRawValue === 'number') cellValue = cellRawValue.toString();
      var formulaCell = cellValue !== undefined && cellValue.charAt(0) === '=';
      var containsOperands = cellValue !== undefined && cellValue.match(/[A-Z]([0-9]{1,10})/gi);
      if (cellValue && column.type === _FieldTableColumnTypes["default"].dropdown) {
        tableLookup[cellKey] = columnOptionsLookup[column._id][cellValue];
      } else if ((cellValue || cellRawValue) && column.type === _FieldTableColumnTypes["default"].image) {
        tableLookup[cellKey] = cellRawValue;
      } else if (cellValue && formulaCell && containsOperands) {
        formulaCells.push(cellKey);
        tableLookup[cellKey] = cellValue;
      } else {
        tableLookup[cellKey] = cellValue || '';
      }
    });
  });
  formulaCells.forEach(function (sourceOperand) {
    var formula = tableLookup[sourceOperand];
    var invalidFormulaError = validFormulaString(sourceOperand, formula);
    if (invalidFormulaError) return tableLookup[sourceOperand] = invalidFormulaError;
    getFormulaResult(sourceOperand, formula, tableLookup);
  });
  return tableLookup;
};
var getFormulaResult = exports.getFormulaResult = function getFormulaResult(sourceOperand, formula, tableLookup) {
  formula = spreadOperandRange(formula);
  var invalidFormulaError = validFormulaString(sourceOperand, formula);
  if (invalidFormulaError) return tableLookup[sourceOperand] = invalidFormulaError;
  var formulaOperands = formula.match(/[A-Z]([0-9]{1,10})/g);
  if (!formulaOperands) return tableLookup[sourceOperand] = '*INVALID';
  formulaOperands.forEach(function (operand) {
    var operandValue = resolveOperandValue(sourceOperand, operand, tableLookup);
    formula = formula.replace(operand, operandValue);
  });

  /**
   * Add leading zeros to decimal numbers. hot-formula-parser throws an
   * error if we try to parse non leading decimal numbers. For instace,
   * a non leading decimal number is: .7 .001 etc. We convert these
   * values to 0.7 & 0.001
   */
  var noLeadingZeroDecimalMatches = formula.match(/\D\./);
  if (noLeadingZeroDecimalMatches && noLeadingZeroDecimalMatches.length > 0) {
    noLeadingZeroDecimalMatches.forEach(function (val) {
      var splitVals = val.split('');
      var prefixCharacter = splitVals[0];
      var newValue = "".concat(prefixCharacter, "0.");
      formula = formula.replace(val, newValue);
    });
  }
  formula = formula.replace('=', '');
  var parsedValue = parser.parse(formula);
  if (parsedValue.result) parsedValue.result = Math.round(100 * parsedValue.result) / 100;
  tableLookup[sourceOperand] = parsedValue.result ? parsedValue.result.toString() : parsedValue.error;
  return parsedValue;
};

/**
 * Resolve operand value
 * An operand is A1, B1, etc.
 *
 * @param sourceOperand //The cell that is requesting the value
 * @param targetOperand //The cell you are trying to retrieve a value from
 * @param tableLookup //The lookup of values contained in the table;
 */
var resolveOperandValue = exports.resolveOperandValue = function resolveOperandValue(sourceOperand, targetOperand, tableLookup) {
  var targetValue = tableLookup[targetOperand] && typeof tableLookup[targetOperand] === 'string' ? tableLookup[targetOperand].trim() : tableLookup[targetOperand];
  /**
   *  1. If tableLookup doesn't have a value (or) if the targetValue
   * appears to be an object (image column cell values) return 0.
   */
  if (!targetValue || (0, _typeof2["default"])(targetValue) === 'object') return 0;

  // 2. If tableLookup is already a number return the number value
  if (typeof targetValue === 'number') return targetValue;

  // 3. If targetCell has circular reference return invalid.
  //
  //  A circular reference can occur when C1 reference B1 and B1 references C1.
  //  It creates and infinite circular loop of trying to resovle a value
  //  because they both depend on eachother.
  if (sourceOperand && hasCircularOperandReference(targetValue, sourceOperand) || targetOperand && hasCircularOperandReference(targetValue, targetOperand)) return '* INVALID - Circular Reference';

  // 4. If targetCell has a formula value
  if (targetValue !== undefined && targetValue.charAt(0) === '=') {
    var result = getFormulaResult(sourceOperand, targetValue, tableLookup);
    return result.result || result.error;
  }

  // 5. If targetCell has a normal value or an already resolved
  //   formula cell then just return the cell value
  if (targetValue) return targetValue;
};
var hasCircularOperandReference = exports.hasCircularOperandReference = function hasCircularOperandReference(targetValue, lookupOperand) {
  var regExp = new RegExp(lookupOperand, 'gi');
  var foundOperandReferences = targetValue.match(regExp);
  return !!(foundOperandReferences && foundOperandReferences.length > 0);
};
var hasOperandRange = exports.hasOperandRange = function hasOperandRange(targetValue) {
  return /[A-Z]([0-9]{1,10}):[A-Z]([0-9]{1,10})/gi.test(targetValue);
};

/**
 * Check for any invalid patterns inside of the formula string
 */
var validFormulaString = exports.validFormulaString = function validFormulaString(sourceOperand, formula) {
  if (sourceOperand && hasCircularOperandReference(formula, sourceOperand)) {
    return '*INVALID - Circular Reference';
  }
  var lowercaseOperands = formula.match(/[a-z]/g);
  if (lowercaseOperands && lowercaseOperands.length > 0) {
    return '*INVALID - Lowercase Letters Not Supported';
  }
};

/**
 * Spread the operand range into individual operands.
 * For instance: SUM(A1:A4) turns into SUM(A1, A2, A3, A4);
 */
var spreadOperandRange = exports.spreadOperandRange = function spreadOperandRange(targetValue) {
  if (!hasOperandRange(targetValue)) return targetValue;
  var operandRangeMatches = targetValue.match(/[A-Z]([0-9]{1,10}):[A-Z]([0-9]{1,10})/gi);
  var operandRange = operandRangeMatches[0];
  var operands = operandRange.split(':');
  var operandA = operands[0];
  var operandALetter = operandA.match(/[A-Z]+/gi) ? operandA.match(/[A-Z]+/gi)[0] : null;
  var operandAIndex = operandA.match(/[0-9]+/gi) ? operandA.match(/[0-9]+/gi)[0] : null;
  var operandB = operands[1];
  var operandBLetter = operandB.match(/[A-Z]+/gi) ? operandB.match(/[A-Z]+/gi)[0] : null;
  var operandBIndex = operandB.match(/[0-9]+/gi) ? operandB.match(/[0-9]+/gi)[0] : null;

  // If any values are missing return orignal targetValue
  if (!operandALetter || !operandAIndex || !operandBLetter || !operandBIndex) return targetValue;

  // Handle row range.
  // For instance: C1:C8
  if (operandALetter === operandBLetter) {
    var columnOperand = operandALetter;
    var startIndex = parseInt(operandAIndex, 10);
    var endIndex = parseInt(operandBIndex, 10);
    var operandRangeValues = operandA;
    var i = startIndex + 1;
    while (i <= endIndex) {
      operandRangeValues += ",".concat(columnOperand).concat(i);
      i++;
    }
    targetValue = targetValue.replace(/[A-Z](\d{1,10}):[A-Z](\d{1,10})/gi, operandRangeValues);
  }

  // Handle column range
  // For instance, A1:D1
  else {
    var _startIndex = parseInt(_Table["default"].operandLetters.indexOf(operandALetter.toUpperCase()), 10);
    var _endIndex = parseInt(_Table["default"].operandLetters.indexOf(operandBLetter.toUpperCase()), 10);
    var _operandRangeValues = operandA;
    var _i = _startIndex + 1;
    while (_i <= _endIndex) {
      var nextOperandLetter = _Table["default"].operandLetters[_i];
      _operandRangeValues += ",".concat(nextOperandLetter).concat(operandAIndex);
      _i++;
    }
    targetValue = targetValue.replace(/[A-Z](\d{1,10}):[A-Z](\d{1,10})/gi, _operandRangeValues);
  }
  return targetValue;
};

/**
 * Primarily used for Mobile
 *
 * Get list of input group fields in an array formt.
 * This breaks the rows and cells down to a single array.
 *
 * @param {Object} field
 * @param {Array} columns
 * @param {Array} rows
 *
 */
var generateInputGroupFields = exports.generateInputGroupFields = function generateInputGroupFields(field, columns) {
  var rows = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [getDefaultRow()];
  var fieldSettings = arguments.length > 3 ? arguments[3] : undefined;
  var activity = arguments.length > 4 ? arguments[4] : undefined;
  var tableReferences = [];
  var tableColumns = getColumns(columns);
  var columnOptionValueLookup = {};
  tableColumns.forEach(function (column) {
    if (column.type === _FieldTableColumnTypes["default"].dropdown && column.options) {
      columnOptionValueLookup[column._id] = {};
      column.options.forEach(function (option) {
        return columnOptionValueLookup[column._id][option._id] = option.value;
      });
    }
  });
  var tableRows = getRows(rows);
  var rowOrder = getTableFieldRowOrder(field._id, fieldSettings, tableRows);
  var sortedTableRows = sortRows(tableRows, rowOrder);
  var cellActivityLookup = {};
  if (activity && activity.length > 0) {
    activity.forEach(function (act) {
      var rowId = act.document.row;
      var columnId = act.document.column;
      var cellKey = "".concat(field._id).concat(rowId).concat(columnId);
      if (!cellActivityLookup[cellKey]) cellActivityLookup[cellKey] = 0;
      cellActivityLookup[cellKey] += 1;
    });
  }
  sortedTableRows.forEach(function (row, rowIndex) {
    var firstRowIndex = rowIndex === 0;
    var lastRowIndex = rowIndex === sortedTableRows.length - 1;

    /**
     * Step 1: Add InputGroup Row Header
     */
    tableReferences.push({
      uniqueId: "".concat(field._id).concat(row._id),
      _id: field._id,
      title: field.title,
      type: _Table.inputGroupFieldTypes.inputGroupRowHeader,
      rowIndex: rowIndex,
      rowId: row._id,
      firstRowIndex: firstRowIndex,
      lastRowIndex: lastRowIndex,
      firstIndex: rowIndex === 0,
      lastIndex: false
    });

    /**
     * Step 2: Add Input Group Row Cells
     */
    tableColumns.forEach(function (column, columnIndex) {
      var lastColumnIndex = columnIndex === tableColumns.length - 1;
      var value = row && row.cells ? row.cells[column._id] : '';
      var displayValue = column.type === _FieldTableColumnTypes["default"].dropdown ? columnOptionValueLookup[column._id][value] : value;
      var cellKey = "".concat(field._id).concat(row._id).concat(column._id);
      tableReferences.push({
        uniqueId: cellKey,
        _id: field._id,
        title: column.title,
        type: column.type === _FieldTableColumnTypes["default"].dropdown ? _Table.inputGroupFieldTypes.inputGroupDropdownCell : _Table.inputGroupFieldTypes.inputGroupTextCell,
        rowIndex: rowIndex,
        rowId: row._id,
        activity: cellActivityLookup[cellKey] || 0,
        columnId: column._id,
        columnIndex: columnIndex,
        value: value,
        displayValue: displayValue,
        firstRowIndex: firstRowIndex,
        lastRowIndex: lastRowIndex,
        firstIndex: false,
        lastIndex: lastRowIndex && lastColumnIndex
      });
    });
  });
  return tableReferences;
};

/**
 * Populate table rows with values
 *  - Dropdown cells will have chosen values
 *  - Formula cells will have the formula result
 *
 * Note: Columns should already have the options lookup populated before
 * being sent into this function
 *
 * @param {*} columns -
 * @param {*} rows
 * @returns
 */

var getTableRowLookupWithPopulatedDropdownCells = exports.getTableRowLookupWithPopulatedDropdownCells = function getTableRowLookupWithPopulatedDropdownCells(columns, rows) {
  var rowsLookup = {};
  var tableLookup = generateTableLookup(rows, columns);
  var validRows = getRows(rows);
  var validColumns = getColumns(columns);
  validRows.forEach(function (row, rowIndex) {
    var nextRow = _objectSpread(_objectSpread({}, row), {}, {
      cells: _objectSpread({}, row.cells)
    });
    validColumns.forEach(function (column) {
      var cellOperand = getCellOperand(column.operand, rowIndex + 1);
      var value = tableLookup[cellOperand];
      if (value && column.type === _FieldTableColumnTypes["default"].dropdown) {
        nextRow.cells[column._id] = column.optionsLookup[value] ? column.optionsLookup[value].value : value;
      } else {
        nextRow.cells[column._id] = value;
      }
    });
    rowsLookup[nextRow._id] = nextRow;
  });
  return rowsLookup;
};

/**
 * Populate inputGroup dropdown questions with chosen value
 *
 * Note: Columns should already have the options lookup populated before
 * being sent into this function
 *
 * @param {*} columns
 * @param {*} rows
 * @returns
 */

var getInputGroupRowLookupWithPopulatedDropdownCells = exports.getInputGroupRowLookupWithPopulatedDropdownCells = function getInputGroupRowLookupWithPopulatedDropdownCells(columns, rows) {
  var rowsLookup = {};
  var validRows = typeof rows === 'string' ? JSON.parse(rows) : rows;
  validRows.forEach(function (row) {
    var nextRow = _objectSpread(_objectSpread({}, row), {}, {
      cells: _objectSpread({}, row.cells)
    });
    columns.forEach(function (column) {
      var optionId = nextRow.cells[column._id];
      if (optionId && column.type === _FieldTableColumnTypes["default"].dropdown) {
        nextRow.cells[column._id] = column.optionsLookup[optionId] ? column.optionsLookup[optionId].value : optionId;
      }
    });
    rowsLookup[nextRow._id] = nextRow;
  });
  return rowsLookup;
};

/**
 * Generate row index lookup:
 * @param {*} fieldId
 * @param {*} fieldSettings
 * @param {*} rows
 * @returns
 */
var getRowIndexLookup = exports.getRowIndexLookup = function getRowIndexLookup(fieldId, fieldSettings, rows) {
  var rowOrder = getTableFieldRowOrder(fieldId, fieldSettings, rows);
  var rowIndexLookup = {};
  rowOrder.forEach(function (rowId, index) {
    rowIndexLookup[rowId] = index;
  });
  return rowIndexLookup;
};

/**
 * Handle Table Cell Change
 *
 * @param {Array} rows //List of current table rows
 * @param {String} rowId
 * @param {String} columnId
 * @param {String} value
 * @param {Func} callback
 */
var handleTableCellChange = exports.handleTableCellChange = function handleTableCellChange(rows, rowId, columnId, val, callback) {
  var targetRowIndex = rows.findIndex(function (row) {
    return row._id === rowId;
  });
  var row = rows[targetRowIndex];
  var cells = row ? row.cells : {};

  //Only save data if value has changed
  if (cells[columnId] !== val && callback) {
    callback({
      targetRowIndex: targetRowIndex,
      row: {
        _id: rowId,
        cells: (0, _defineProperty2["default"])({}, columnId, val)
      }
    });
  }
};

/**
 * Handle Insert Table Row
 *
 * @param {Number} rowIndex
 * @param {Func} callback
 */
var handleInsertTableRow = exports.handleInsertTableRow = function handleInsertTableRow(rowIndex, callback) {
  if (callback) callback({
    targetRowIndex: rowIndex + 1,
    row: getDefaultRow()
  });
};

/**
 * Handle Create New Table Row
 *
 * @param {Array} rows //List of current table rows
 * @param {Func} callback
 */
var handleCreateTableRow = exports.handleCreateTableRow = function handleCreateTableRow(rows, callback) {
  var targetRowIndex = rows.length;
  if (callback) callback({
    targetRowIndex: targetRowIndex,
    row: getDefaultRow()
  });
};

/**
 * Handle Duplicate Table Row
 *
 * @param {Array} rows //List of current table rows
 * @param {String} rowId
 * @param {Number} rowIndex
 * @param {Func} callback
 */
var handleDuplicateTableRow = exports.handleDuplicateTableRow = function handleDuplicateTableRow(rows, rowId, rowIndex, callback) {
  var duplicateRow = rows.find(function (row) {
    return row._id === rowId;
  });
  var newRow = getDefaultRow();
  newRow.cells = duplicateRow && duplicateRow.cells ? _objectSpread({}, duplicateRow.cells) : {};
  var targetRowIndex = rowIndex + 1;
  if (callback) callback({
    targetRowIndex: targetRowIndex,
    row: newRow
  });
};

/**
 * Handle Move Table Row Up
 *
 * @param {Number} rowIndex
 * @param {Func} callback
 */
var handleMoveTableRowUp = exports.handleMoveTableRowUp = function handleMoveTableRowUp(rowIndex, callback) {
  //If first row then ignore
  if (rowIndex === 0) return;
  var targetRowIndex = rowIndex - 1;
  if (callback) callback({
    targetRowIndex: targetRowIndex
  });
};

/**
 * Handle Move Table Row Down
 *
 * @param {Array} rows
 * @param {Number} rowIndex
 * @param {Func} callback
 */
var handleMoveTableRowDown = exports.handleMoveTableRowDown = function handleMoveTableRowDown(rows, rowIndex, callback) {
  //If last row then ignore
  if (rowIndex >= rows.length - 1) return;
  var targetRowIndex = rowIndex + 1;
  if (callback) callback({
    targetRowIndex: targetRowIndex
  });
};
var _default = exports["default"] = {
  generateTableLookup: generateTableLookup,
  generateTableLookupForRows: generateTableLookupForRows,
  generateInputGroupFields: generateInputGroupFields,
  getTargetColumnWithOperand: getTargetColumnWithOperand,
  getColumnOperand: getColumnOperand,
  getCellOperand: getCellOperand,
  getIndexesFromTableCellOperand: getIndexesFromTableCellOperand,
  getRowOrder: getRowOrder,
  getTableFieldRowOrder: getTableFieldRowOrder,
  getFilteredRowOrder: getFilteredRowOrder,
  getCleanedRowOrder: getCleanedRowOrder,
  getRows: getRows,
  sortRows: sortRows,
  getDefaultRow: getDefaultRow,
  getRowMap: getRowMap,
  getDefaultColumnOption: getDefaultColumnOption,
  getDefaultTextColumn: getDefaultTextColumn,
  getDefaultDropdownColumn: getDefaultDropdownColumn,
  getColumnOrder: getColumnOrder,
  getColumns: getColumns,
  sortColumns: sortColumns,
  getFormulaResult: getFormulaResult,
  resolveOperandValue: resolveOperandValue,
  hasCircularOperandReference: hasCircularOperandReference,
  validFormulaString: validFormulaString,
  hasOperandRange: hasOperandRange,
  spreadOperandRange: spreadOperandRange,
  getTableFieldLookupKey: getTableFieldLookupKey,
  getTableRowLookupWithPopulatedDropdownCells: getTableRowLookupWithPopulatedDropdownCells,
  getInputGroupRowLookupWithPopulatedDropdownCells: getInputGroupRowLookupWithPopulatedDropdownCells,
  getRowIndexLookup: getRowIndexLookup,
  handleMoveColumnLeft: handleMoveColumnLeft,
  handleMoveColumnRight: handleMoveColumnRight,
  handleTableCellChange: handleTableCellChange,
  handleInsertTableRow: handleInsertTableRow,
  handleCreateTableRow: handleCreateTableRow,
  handleDuplicateTableRow: handleDuplicateTableRow,
  handleMoveTableRowUp: handleMoveTableRowUp,
  handleMoveTableRowDown: handleMoveTableRowDown,
  FieldTableColumnTypes: _FieldTableColumnTypes["default"],
  FieldTableCustomColumnIds: _FieldTableCustomColumnIds["default"]
};